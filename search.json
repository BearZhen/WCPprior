[{"path":"https://vpnsctl.github.io/WCPprior/articles/INLA_and_Stan_utilities.html","id":"using-wcp-prior-in-r-inla","dir":"Articles","previous_headings":"","what":"Using WCP prior in R-INLA","title":"Bridge to R-INLA and Stan","text":"package allows user provide WCP prior form R-INLA software can use. give example WCP\\(_2\\) prior \\(\\phi\\) stationary AR(1) processes. model setup theoretical details can found Section 3.1 https://arxiv.org/pdf/2312.04481.pdf. generate WCP\\(_2\\) prior analytic expression. Functions encode analytic expression WCP priors package similar usage. univariate prior, functions take sequence values parameter interests bivariate priors, functions take one pair values two parameters. users set argument ‘inla_table’ TRUE, function output prior format R-INLA can use. first simulate stationary AR(1) process length 10, standard deviation 0.1 \\(\\phi = 0.2\\). function ‘WCP2_1D_AR1_analytic’ package gives true WCP\\(_2\\) \\(\\phi \\[-1,1)\\).  Now show bivariate example ","code":"# import INLA library(WCPprior) library(INLA) ## Loading required package: Matrix ## Loading required package: sp ## This is INLA_23.11.01 built 2023-11-01 19:16:01 UTC. ##  - See www.r-inla.org/contact-us for how to get help. ##  - List available models/likelihoods/etc with inla.list.models() ##  - Use inla.doc(<NAME>) to access documentation # length of the AR1 process n = 10 # standard deviation of the process sigma = 0.1 # value of phi phi = 0.2 # simulate the process sim_data = numeric(n) sim_data[1] = rnorm(1,mean = 0, sd = sigma) for (i in 2:n){  sim_data[i] = phi*sim_data[i-1] + rnorm(1, mean = 0, sd = sigma*sqrt(1-phi^2) ) } data = data.frame(y = sim_data, t = 1:n) # create a sequence of values of phi seq_phi = seq(from = -1, to = 0.99, by = 0.01) # call the function and set inla_table = TRUE so that the function will return a prior that can be used by INLA WCP2_prior_table = WCP2_1D_AR1_analytic (seq_phi = seq_phi,                                 eta = 7,                                n = 13,                                sigma = sigma,                                inla_table = TRUE) # INLA formula formula = y~ -1+f(t,model='ar1',hyper = WCP2_prior_table) family = \"Gaussian\" # fit the model by INLA result = inla(formula=formula, data = data, family=family,              control.predictor = list(compute=T)) summary(result) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" keep = keep, working.directory = working.directory,  ##    silent = silent, \", \" inla.mode = inla.mode, safe = FALSE, debug =  ##    debug, .parent.frame = .parent.frame)\" )  ## Time used: ##     Pre = 7.5, Running = 0.869, Post = 0.0228, Total = 8.39  ## Random effects: ##   Name     Model ##     t AR1 model ##  ## Model hyperparameters: ##                                             mean       sd 0.025quant 0.5quant ## Precision for the Gaussian observations 1.91e+02 8.02e+01     75.281 1.77e+02 ## Precision for t                         2.17e+04 2.40e+04   1386.396 1.41e+04 ## Rho for t                               5.00e-03 6.97e-01     -0.987 9.00e-03 ##                                         0.975quant     mode ## Precision for the Gaussian observations   3.85e+02  152.118 ## Precision for t                           8.55e+04 3749.707 ## Rho for t                                 9.88e-01    0.997 ##  ## Marginal log-Likelihood:  6.19  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') # visualize the result plot(data$y, col=\"blue\",      ylab=\"fitting result\") lines(result$summary.random$t[ ,\"mean\"])"},{"path":"https://vpnsctl.github.io/WCPprior/articles/numerical_WCP.html","id":"an-example-with-numerical-approximation-of-bivariate-wcp_2-prior-of-mean-and-standard-deviation-of-gaussian-distribution-","dir":"Articles","previous_headings":"","what":"An example with numerical approximation of bivariate WCP\\(_2\\) prior of mean and standard deviation of Gaussian distribution.","title":"Numerical approximations of WCP priors","text":"theoretical details deriving bivariate WCP prior density can found Recipe 1, Section 4.2 https://arxiv.org/pdf/2312.04481.pdf, implementation details can found Recipe 4, Section 5.2 document. function gives numerical approximation bivariate WCP prior requires information. (1), function takes values two-dimensional parameter \\(\\boldsymbol{\\theta} = (\\theta_1, \\theta_2)\\) returns Wasserstein distance \\(W(\\boldsymbol{\\theta})\\). (2), \\(\\eta\\), user-specified hyperparameter WCP prior. (3), cutoff parameter determines upper bound Wasserstein distance \\(W\\) case parameter space \\(\\boldsymbol{\\theta}\\) unbounded. , solving \\(P(W > w) = \\text{cutoff}\\), upper bound \\(w = -log(\\text{cutoff})/\\eta\\). Thus, can approximate WCP prior bounded domain. (4), region information specifies boundary bounded domain \\(\\boldsymbol{\\theta}\\) determined cutoff, type shape domain. (5), mesh width determine fine mesh bounded domain. Let us define Wasserstein distance function, x[1] mean parameter, x[2] standard deviation parameter: now define parameters region: Observe type region conic, range angle conic region 0 \\(\\pi\\) base model parameter (0,0). following code performs approximation using WCP_2D_Numerical_Density() function. setting parallel = TRUE, user can run function multiple cores NumCores specifies number cores. set visual_mesh = TRUE obtain plot region along constructed mesh.  function returns values approximated density along level curves. goal now plot approximated density. end, obtain approximated values mesh, plot values pixelated cover mesh. begin extracting mesh creating pixelized mesh fm_pixels() function fmesher package. now obtain values approximated density mesh nodes. end, need elements basis val returned list. basis contains matrix maps level curve locations mesh nodes, val contains values approximated density level curve locations. Let us obtain values approximated density pixelated mesh: Let us now plot approximated density log scale:  Now show absolute error true approximated densities. begin obtaining values true density pixelated locations: can now add absolute errors pxl list: Now, error plot log scale:  compute total variation distance true approximated distribution, can following. start obtainig lumped mass matrix, matrix contains areas triangles mesh: Let us now obtain value true density mesh locations: can now compute approximation total variation norm: package also provides function compute point-wise analytic bivariate WCP\\(_2\\) prior mean standard deviation Gaussian distribution. use function, users just need provide values parameters, \\(\\eta\\) base model mean parameter \\(\\text{base_mean}\\). base model standard deviation parameter fixed 0. Now use function compute densities coordinates numerical approximation densities computed. Let us start obtaining analytic density help WCP2_2D_Gaussian_analytic() function Let us now compare density true density computed manually: now plot analytic density:","code":"W_func <- function(x){sqrt(x[1]^2+x[2]^2)} cutoff = 0.01 mesh_width = 0.3 # user-specified hyperparameter eta = 1  region = list(type = 'conic', lower_angle = 0,  upper_angle = pi, base_theta = c(0,0)) result = WCP_2D_Numerical_Density(W_func,                           eta = eta,                           mesh_width = mesh_width,                            cutoff = cutoff,                            region = region,                           parallel = TRUE,                           NumCores = 3,                           visual_mesh = TRUE) library(fmesher) mesh <- result$mesh pxl <- fm_pixels(mesh) basis <- result$basis dens_val <- result$val  dens_mesh <- basis%*%dens_val pxl$val <-      fm_evaluate(mesh, pxl, field =        dens_mesh) library(viridis) ## Loading required package: viridisLite ggplot() +     geom_tile(       data = pxl,       aes(geometry = geometry, fill = log(val)),       stat = \"sf_coordinates\"     ) + scale_fill_viridis() library(sf) ## Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE coord_pxl <- st_coordinates(pxl) # compute the true density true_WCP_density = ( 1/sqrt(coord_pxl[,1]^2 +                  coord_pxl[,2]^2) ) * eta *                  exp(-eta * sqrt(coord_pxl[,1]^2 +                  coord_pxl[,2]^2))/pi pxl$error <- abs(pxl$val - true_WCP_density) ggplot() +     geom_tile(       data = pxl,       aes(geometry = geometry, fill = log(error)),       stat = \"sf_coordinates\"     ) + scale_fill_viridis() mass_lump_C <- result$C true_WCP_density_mesh = ( 1/sqrt(mesh$loc[,1]^2 +                  mesh$loc[,2]^2) ) * eta *                  exp(-eta * sqrt(mesh$loc[,1]^2 +                  mesh$loc[,2]^2))/pi TVD_error = 0.5 * (sum(mass_lump_C %*%        abs(matrix(dens_mesh,ncol = 1) -          matrix(true_WCP_density_mesh,ncol = 1))) +          cutoff) print(TVD_error) ## [1] 0.09359713 analytic_density = numeric()  for (i in 1:length(coord_pxl[,1])){   analytic_density[i] =              WCP2_2D_Gaussian_analytic(mean =                        coord_pxl[i,1],                        std = coord_pxl[i,2],                       eta = 1,                       base_mean = 0) } print(sum(abs(true_WCP_density - analytic_density))) ## [1] 0 data = cbind(as.vector(coord_pxl[,1]),           as.vector(coord_pxl[,2]),           as.vector(analytic_density)) data = data.frame(data) g = ggplot(data, aes(X1, X2, fill = log(X3)))+   geom_raster()+   scale_fill_viridis() +   labs(x = expression(theta[1]), y = expression(theta[2])) +    guides(col = guide_colourbar(title = \"Density\"))+   theme(legend.position = \"top\",         legend.key.height = unit(0.1, 'cm'), #change legend key height         legend.key.width = unit(0.5, 'cm'), #change legend key width         legend.title = element_text(size=7), #change legend title font size         legend.text = element_text(size=5),#change legend text font size         axis.text=element_text(size=7),         axis.title=element_text(size=7))  g"},{"path":"https://vpnsctl.github.io/WCPprior/articles/numerical_WCP.html","id":"an-example-with-numerical-approximation-of-1d-wcp_2-prior-of-reciprocal-of-degree-of-freedom-parameter-of-t-distribution-","dir":"Articles","previous_headings":"","what":"An example with numerical approximation of 1d WCP\\(_2\\) prior of reciprocal of degree of freedom parameter of t-distribution.","title":"Numerical approximations of WCP priors","text":"theoretical implementation details WCP\\(_2\\) prior reciprocal degree freedom parameter t-distribution can found Section 5.1 https://arxiv.org/pdf/2312.04481.pdf. Let \\(\\xi\\) denote parameter interest. use function construct numerical approximation WCP prior single parameter, users need provide following information general: (1), function takes values two-dimensional parameter \\(\\theta\\) returns Wasserstein distance \\(W(\\theta)\\). (2), \\(\\theta_0\\), base model parameter. (3), \\(\\eta\\), user-specified hyperparameter WCP prior. (4), cutoff parameter. (5), Lower upper bound domain \\(\\theta\\) two values included . Since \\(\\xi\\[0,1/2)\\) bounded domain, need provide cutoff parameter case. Also, analytic expression \\(W(\\xi)\\) available case, compute numerically numerical integration (see Remark 1 https://arxiv.org/pdf/2312.04481.pdf). However, call function frequently economic, construct interpolated function \\(W(\\xi)\\) following code. determine \\(\\eta\\) requiring \\(P(\\text{W}(\\xi) > U) = \\alpha\\). Now ready call function compute numerically approximated WCP prior. \\(\\text{base_theta}\\) base model parameter. \\(\\text{L}\\) \\(\\text{U}\\) denote lower upper bound \\(\\theta\\). \\(\\text{L_included}\\) \\(\\text{U_included}\\) indicate \\(\\text{L}\\) \\(\\text{U}\\) included interval parameter interest. \\(\\text{mesh_width}\\) denote mesh width domain. User may instead input \\(\\text{mesh_n}\\) specifies number mesh nodes determine mesh. output contains vector values \\(\\xi\\) vector approximated densities evaluated \\(\\xi\\). visualization result :","code":"library(fGarch) ## NOTE: Packages 'fBasics', 'timeDate', and 'timeSeries' are no longer ## attached to the search() path when 'fGarch' is attached. ##  ## If needed attach them yourself in your R script by e.g., ##         require(\"timeSeries\") # The Wasserstein distance function by numerical integration W2distanceGt = function(xi){   # xi is 1/nu where nu is dof of t-distribution   integrand = function(p,...){     abs(qstd(p,...) - qnorm(p))^2   }   integral = integrate(Vectorize(integrand),0,1,        nu = 1/xi,subdivisions = 10000L)$value   return (integral^(1/2)) } # a sequence of xi Xi = seq(from = 0.01,to = 0.49,by = 0.01) # obtain a sequence of W(xi) by W2distanceGt function W2distance = c() xi = c() for (i in 1:length(Xi)){   # skip the case of problematic numerical integration   temp = try(W2distanceGt(Xi[i]), silent = FALSE)   if ('try-error' %in% class(temp)){     next   }   W2distance = c(W2distance, W2distanceGt(Xi[i]) )   xi = c(xi, Xi[i]) } # the interpolated function of W(xi) W2d = splinefun(xi, W2distance, method = \"hyman\") alpha = 0.3 U = 0.1 eta = -log(alpha)/W2d(U) result = WCP_1D_Numerical_Density(base_theta = 0,                                    L = 0,                                     L_included = TRUE,                                    U = 0.5,                                    U_included = FALSE,                                    W_func = W2d,                                    eta = eta,                                    mesh_width = 0.001) data <- data.frame(x = result[,1], density = result[, 2]) ggplot(data, aes(x = x, y = density)) + geom_line()"},{"path":"https://vpnsctl.github.io/WCPprior/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Author. Alexandre Simas. Maintainer, author. Zhen Xiong. Author.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bolin D, Simas , Xiong Z (2023). WCPprior: Wasserstein Complexity Penalization Priors. R package version 1.0, https://vpnsctl.github.io/WCPprior/.","code":"@Manual{,   title = {WCPprior: Wasserstein Complexity Penalization Priors},   author = {David Bolin and Alexandre Simas and Zhen Xiong},   year = {2023},   note = {R package version 1.0},   url = {https://vpnsctl.github.io/WCPprior/}, }"},{"path":[]},{"path":"https://vpnsctl.github.io/WCPprior/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Wasserstein Complexity Penalization Priors","text":"WCPprior R package used obtain numerical approximation Wasserstein complexity penalization (WCP) priors. package also contains several analytical WCP priors well implementations STAN INLA.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Wasserstein Complexity Penalization Priors","text":"latest development version can installed using command latest stable version can installed using command","code":"remotes::install_github(\"vpnsctl/WCPprior\", ref = \"devel\") remotes::install_github(\"vpnsctl/WCPprior\", ref = \"stable\")"},{"path":"https://vpnsctl.github.io/WCPprior/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Wasserstein Complexity Penalization Priors","text":"D. Bolin, . Simas, Z. Xiong (2023+) Wasserstein complexity penalization priors: new class penalizing complexity priors. arXiv preprint.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_1D_GPtail_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","title":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","text":"1d analytic density WCP prior xi generalized Pareto distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_1D_GPtail_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","text":"","code":"WCP1_1D_GPtail_analytic(seq_xi, eta, inla_table = FALSE)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_1D_GPtail_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","text":"seq_xi vector values xi parameter. eta User specified parameter WCP prior. inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_1D_GPtail_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","text":"list including densities seq_xi inla table","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_2D_GP_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","title":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","text":"2d analytic density WCP prior sigma xi generalized Pareto distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_2D_GP_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","text":"","code":"WCP1_2D_GP_analytic(sigma, xi, eta)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_2D_GP_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","text":"sigma Sigma parameter. xi Xi parameter. eta User specified parameter WCP prior.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_2D_GP_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","text":"value density evaluated c(sigma, xi).","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_AR1_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","title":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","text":"1d analytic density WCP prior phi stationary AR1 process","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_AR1_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","text":"","code":"WCP2_1D_AR1_analytic(seq_phi, eta, n, sigma, inla_table = FALSE)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_AR1_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","text":"seq_phi vector values phi parameter. eta User specified parameter WCP prior. n Length AR1 process. sigma Standard deviation process. inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_AR1_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","text":"list including densities seq_phi inla table","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_mean_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","title":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","text":"1d analytic density WCP2 prior mean Gaussian distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_mean_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","text":"","code":"WCP2_1D_Gaussian_mean_analytic(seq_m, eta, inla_table = FALSE)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_mean_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","text":"seq_m vector values mean parameter. eta User specified parameter WCP prior. inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_mean_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","text":"list including densities seq_m inla table","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_precision_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","title":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","text":"1d analytic density WCP2 prior tau (1/variance) Gaussian distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_precision_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","text":"","code":"WCP2_1D_Gaussian_precision_analytic(seq_tau, eta, inla_table = FALSE)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_precision_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","text":"seq_tau vector values tau parameter. eta User specified parameter WCP prior. inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_precision_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","text":"list including densities seq_tau inla table","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_2D_Gaussian_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","title":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","text":"2d analytic density WCP prior mean standard deviation Gaussian distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_2D_Gaussian_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","text":"","code":"WCP2_2D_Gaussian_analytic(mean, std, eta, base_mean)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_2D_Gaussian_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","text":"mean Mean parameter. std Standard deviation parameter. eta User specified parameter WCP prior. base_mean Base model value mean parameter.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_2D_Gaussian_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","text":"value density evaluated c(mean, std).","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_1D_Numerical_Density.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","title":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","text":"1d numerical density WCP prior","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_1D_Numerical_Density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","text":"","code":"WCP_1D_Numerical_Density(   W_func,   eta,   base_theta,   L,   U,   mesh_width = NULL,   mesh_n = 100,   cutoff1 = 0.01,   cutoff2 = NULL,   L_included = FALSE,   U_included = FALSE,   inla_table = FALSE )"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_1D_Numerical_Density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","text":"W_func function returns Wasserstein distance given theta. eta User specified parameter WCP prior. base_theta Base model theta. L Lower bound theta. U Upper bound theta. mesh_width Mesh width used. used, mesh_n used. mesh_n Number mesh nodes used. used mesh_width given. cutoff1 Cutoff parameter decide upper bound Wasserstein distance right hand side base_theta. cutoff2 Cutoff parameter decide upper bound Wasserstein distance left hand side base_theta. L_included L included domain, TRUE FALSE value U_included U included domain, TRUE FALSE value inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_1D_Numerical_Density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","text":"list density locations densities evaluated locations.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_2D_Numerical_Density.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","title":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","text":"2d numerical approximation WCP prior","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_2D_Numerical_Density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","text":"","code":"WCP_2D_Numerical_Density(   W_func,   eta,   mesh_width,   alpha = 1,   tau = mesh_width/1000,   cutoff = 0.01,   region = list(type = \"conic\", lower_angle = 0, upper_angle = pi, base_theta = c(0, 0)),   lc_multiplier = 20,   buff_boundary = FALSE,   parallel = FALSE,   NumCores = parallel::detectCores() - 1,   visual_mesh = FALSE )"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_2D_Numerical_Density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","text":"W_func function returns Wasserstein distance given theta1 theta2. eta User specified parameter WCP prior. mesh_width Mesh width. alpha Power mesh width finer mesh. tau tau parameter, indicating much bounded away boundary. cutoff Cutoff parameter indicating probability tail mass Wasserstein distance. region list specify region information. example, strip regions (regions type IxJ, = (,b) J = (c,d) intervals, one unbounded), one can set `region = list(type = \"strip\", base_theta = c(,c), corners = c(,b,c,d))`, values ``,`b`,`c` `d` can `-Inf` `Inf`. type conic, list must set, example, list(type = 'conic', lower_angle = 0, upper_angle = pi, base_theta = c(0,0)), `lower_angle` `upper_angle` contains smaller larger angles determine cone. lc_multiplier Multiplier determines number level curves buff_boundary additional buffer (magnitude mesh_width) added region bound away boundary domain? parallel logic value indicating whether user wants run function multiple cpu. NumCores Number cores run function. visual_mesh logic value determin whether plot mesh.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_2D_Numerical_Density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","text":"list density locations, densities evaluated locations utilities can help access accuracy.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCPprior.html","id":null,"dir":"Reference","previous_headings":"","what":"Wasserstein Complexity Penalization Priors — WCPprior","title":"Wasserstein Complexity Penalization Priors — WCPprior","text":"'WCPprior' provides tools computing Wasserstein complexity penalization priors.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/compute_partial_arc_lengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute partial arc lengths — compute_partial_arc_lengths","title":"Compute partial arc lengths — compute_partial_arc_lengths","text":"Computes partial arc lengths matrix coordinates SpatialLine","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/compute_partial_arc_lengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute partial arc lengths — compute_partial_arc_lengths","text":"","code":"compute_partial_arc_lengths(coords)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/compute_partial_arc_lengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute partial arc lengths — compute_partial_arc_lengths","text":"coords [nx2 matrix] Matrix points lines","code":""}]
