[{"path":"https://vpnsctl.github.io/WCPprior/articles/INLA_and_Stan_utilities.html","id":"using-univariate-wcp-prior-in-r-inla","dir":"Articles","previous_headings":"","what":"Using univariate WCP prior in R-INLA","title":"Bridge to R-INLA and Stan","text":"package allows user provide WCP prior form R-INLA software can use. give example WCP2_2 prior ϕ\\phi stationary AR(1) processes. model setup theoretical details can found Section 3.1 https://arxiv.org/pdf/2312.04481.pdf. generate WCP2_2 prior analytic expression. Functions encode analytic expression WCP priors package similar usage. univariate prior, functions take sequence values parameter interests bivariate priors, functions take one pair values two parameters. users set argument ‘inla_table’ TRUE, function output prior format R-INLA can use. now load R-INLA WCPprior library. first simulate stationary AR(1) process length 10. set standard deviation σ=0.1\\sigma = 0.1 ϕ=0.2\\phi = 0.2. Now ready setup WCP2_2 prior ϕ\\phi using function ‘WCP2_1D_AR1_analytic’ WCPprior package. User input sequence values ϕ∈[−1,1]\\phi \\[-1,1] information nn, σ\\sigma η\\eta. setting ‘inla_table = TRUE’, output function can directly used INLA specifying prior formula. , ready fit model simulated process WCP prior INLA. Finally, visualize result.","code":"library(WCPprior) library(INLA) # length of the AR1 process n = 10 # standard deviation of the process sigma = 0.1 # value of phi phi = 0.2 # simulate the process sim_data = numeric(n) sim_data[1] = rnorm(1,mean = 0, sd = sigma) for (i in 2:n){  sim_data[i] = phi*sim_data[i-1] + rnorm(1, mean = 0, sd = sigma*sqrt(1-phi^2) ) } data = data.frame(y = sim_data, t = 1:n) # create a sequence of values of phi seq_phi = seq(from = -1, to = 0.999, by = 0.001) # call the function and set inla_table = TRUE so that the function will return a prior that can be used by INLA WCP2_prior_table = WCP2_1D_AR1_analytic (seq_phi = seq_phi,                                 eta = 15,                                n = 10,                                sigma = sigma,                                inla_table = TRUE) formula = y~ -1+f(t,model='ar1',hyper = WCP2_prior_table) result = inla(formula=formula, data = data, family=\"Gaussian\",              control.predictor = list(compute=T))  summary(result) ## Time used: ##     Pre = 0.384, Running = 0.163, Post = 0.0195, Total = 0.567  ## Random effects: ##   Name     Model ##     t AR1 model ##  ## Model hyperparameters: ##                                             mean       sd 0.025quant 0.5quant ## Precision for the Gaussian observations 9.76e+01    40.60     38.582 9.08e+01 ## Precision for t                         2.18e+04 23499.98   1440.889 1.44e+04 ## Rho for t                               1.00e-03     0.70     -0.988 2.00e-03 ##                                         0.975quant     mode ## Precision for the Gaussian observations   1.95e+02   78.150 ## Precision for t                           8.42e+04 3929.066 ## Rho for t                                 9.88e-01    0.998 ##  ## Marginal log-Likelihood:  2.19  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') plot(data$y, col=\"blue\",      ylab=\"fitting result\") lines(result$summary.random$t[ ,\"mean\"])"},{"path":"https://vpnsctl.github.io/WCPprior/articles/INLA_and_Stan_utilities.html","id":"using-univariate-wcp-prior-in-stan","dir":"Articles","previous_headings":"","what":"Using univariate WCP prior in stan","title":"Bridge to R-INLA and Stan","text":"WCPprior package also provides format univariate WCP priors can used stan. implemented priors : (1), WCP2_2 prior ϕ\\phi stationary AR(1) process. (WCP2_1D_AR1_analytic) (2), WCP1_1 prior ξ\\xi, tail index, generalized Pareto distribution. (WCP1_1D_GPtail_analytic) (3), WCP2_2 prior precision parameter (reciprocal variance) Gaussian distribution. (WCP2_1D_Gaussian_precision_analytic) (4), WCP2_2 prior mean parameter Gaussian distribution. (WCP2_1D_Gaussian_mean_analytic) show example using ‘WCP2_1D_AR1_analytic’ function stan. first block stan file function block includes implemented functions WCPprior package. second block specifies data. AR(1) process, y, length NN. third block specifies parameter interests, ϕ\\phi range [−1,1][-1,1] last block specifies model setup including log-likelihood process log-likehood WCP prior. , first argument function ‘WCP2_1D_AR1_analytic’ length process, second one value η\\eta last one value σ\\sigma (standard deviation process). Let us now create stan file build model. stored model object. Let us sample AR1 process, n length process: now fit model stan. Observe calling sampling function model R object. Let us plot fitted model:","code":"functions { #include /include/WCP_analytic.stan } data {   int<lower=0> N;   vector[N] y; } parameters {   real<lower = -1, upper = 1> phi; } model {   for (n in 2:N)     y[n] ~ normal(phi * y[n-1], 0.1);   phi ~ WCP2_1D_AR1_analytic(N, 2.172101, 0.1); } functions { #include ../inst/stan/include/WCP_analytic.stan } data {   int<lower=0> N;   vector[N] y; } parameters {   real<lower = -1, upper = 1> phi; } model {   for (n in 2:N){     y[n] ~ normal(phi * y[n-1], 0.1);   }   phi ~ WCP2_1D_AR1_analytic(N, 2.172101, 0.1); } n = 100 sigma = 0.1 phi = 0.8 sim_data = numeric(n) sim_data[1] = rnorm(1,mean = 0, sd = sigma) for (i in 2:n){   sim_data[i] = phi*sim_data[i-1] + rnorm(1, mean = 0, sd = sigma*sqrt(1-phi^2) ) } data <- list(N = 100L,               y = sim_data) library(rstan) fit_WCP_AR <- sampling(model, data = data, iter = 1000) ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). ## Chain 1:  ## Chain 1: Gradient evaluation took 3e-05 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.3 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1:  ## Chain 1:  ## Chain 1: Iteration:   1 / 1000 [  0%]  (Warmup) ## Chain 1: Iteration: 100 / 1000 [ 10%]  (Warmup) ## Chain 1: Iteration: 200 / 1000 [ 20%]  (Warmup) ## Chain 1: Iteration: 300 / 1000 [ 30%]  (Warmup) ## Chain 1: Iteration: 400 / 1000 [ 40%]  (Warmup) ## Chain 1: Iteration: 500 / 1000 [ 50%]  (Warmup) ## Chain 1: Iteration: 501 / 1000 [ 50%]  (Sampling) ## Chain 1: Iteration: 600 / 1000 [ 60%]  (Sampling) ## Chain 1: Iteration: 700 / 1000 [ 70%]  (Sampling) ## Chain 1: Iteration: 800 / 1000 [ 80%]  (Sampling) ## Chain 1: Iteration: 900 / 1000 [ 90%]  (Sampling) ## Chain 1: Iteration: 1000 / 1000 [100%]  (Sampling) ## Chain 1:  ## Chain 1:  Elapsed Time: 0.042 seconds (Warm-up) ## Chain 1:                0.029 seconds (Sampling) ## Chain 1:                0.071 seconds (Total) ## Chain 1:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2). ## Chain 2:  ## Chain 2: Gradient evaluation took 1.8e-05 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.18 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2:  ## Chain 2:  ## Chain 2: Iteration:   1 / 1000 [  0%]  (Warmup) ## Chain 2: Iteration: 100 / 1000 [ 10%]  (Warmup) ## Chain 2: Iteration: 200 / 1000 [ 20%]  (Warmup) ## Chain 2: Iteration: 300 / 1000 [ 30%]  (Warmup) ## Chain 2: Iteration: 400 / 1000 [ 40%]  (Warmup) ## Chain 2: Iteration: 500 / 1000 [ 50%]  (Warmup) ## Chain 2: Iteration: 501 / 1000 [ 50%]  (Sampling) ## Chain 2: Iteration: 600 / 1000 [ 60%]  (Sampling) ## Chain 2: Iteration: 700 / 1000 [ 70%]  (Sampling) ## Chain 2: Iteration: 800 / 1000 [ 80%]  (Sampling) ## Chain 2: Iteration: 900 / 1000 [ 90%]  (Sampling) ## Chain 2: Iteration: 1000 / 1000 [100%]  (Sampling) ## Chain 2:  ## Chain 2:  Elapsed Time: 0.039 seconds (Warm-up) ## Chain 2:                0.035 seconds (Sampling) ## Chain 2:                0.074 seconds (Total) ## Chain 2:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3). ## Chain 3:  ## Chain 3: Gradient evaluation took 1.8e-05 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.18 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3:  ## Chain 3:  ## Chain 3: Iteration:   1 / 1000 [  0%]  (Warmup) ## Chain 3: Iteration: 100 / 1000 [ 10%]  (Warmup) ## Chain 3: Iteration: 200 / 1000 [ 20%]  (Warmup) ## Chain 3: Iteration: 300 / 1000 [ 30%]  (Warmup) ## Chain 3: Iteration: 400 / 1000 [ 40%]  (Warmup) ## Chain 3: Iteration: 500 / 1000 [ 50%]  (Warmup) ## Chain 3: Iteration: 501 / 1000 [ 50%]  (Sampling) ## Chain 3: Iteration: 600 / 1000 [ 60%]  (Sampling) ## Chain 3: Iteration: 700 / 1000 [ 70%]  (Sampling) ## Chain 3: Iteration: 800 / 1000 [ 80%]  (Sampling) ## Chain 3: Iteration: 900 / 1000 [ 90%]  (Sampling) ## Chain 3: Iteration: 1000 / 1000 [100%]  (Sampling) ## Chain 3:  ## Chain 3:  Elapsed Time: 0.04 seconds (Warm-up) ## Chain 3:                0.033 seconds (Sampling) ## Chain 3:                0.073 seconds (Total) ## Chain 3:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4). ## Chain 4:  ## Chain 4: Gradient evaluation took 1.8e-05 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.18 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4:  ## Chain 4:  ## Chain 4: Iteration:   1 / 1000 [  0%]  (Warmup) ## Chain 4: Iteration: 100 / 1000 [ 10%]  (Warmup) ## Chain 4: Iteration: 200 / 1000 [ 20%]  (Warmup) ## Chain 4: Iteration: 300 / 1000 [ 30%]  (Warmup) ## Chain 4: Iteration: 400 / 1000 [ 40%]  (Warmup) ## Chain 4: Iteration: 500 / 1000 [ 50%]  (Warmup) ## Chain 4: Iteration: 501 / 1000 [ 50%]  (Sampling) ## Chain 4: Iteration: 600 / 1000 [ 60%]  (Sampling) ## Chain 4: Iteration: 700 / 1000 [ 70%]  (Sampling) ## Chain 4: Iteration: 800 / 1000 [ 80%]  (Sampling) ## Chain 4: Iteration: 900 / 1000 [ 90%]  (Sampling) ## Chain 4: Iteration: 1000 / 1000 [100%]  (Sampling) ## Chain 4:  ## Chain 4:  Elapsed Time: 0.044 seconds (Warm-up) ## Chain 4:                0.03 seconds (Sampling) ## Chain 4:                0.074 seconds (Total) ## Chain 4: plot(fit_WCP_AR) ## ci_level: 0.8 (80% intervals) ## outer_level: 0.95 (95% intervals)"},{"path":"https://vpnsctl.github.io/WCPprior/articles/INLA_and_Stan_utilities.html","id":"using-bivariate-wcp-prior-in-stan","dir":"Articles","previous_headings":"","what":"Using bivariate WCP prior in stan","title":"Bridge to R-INLA and Stan","text":"following two bivariate WCP priors also implemented stan functions WCPprior package: (1), Bivariate WCP2_2 prior mean standard deviation parameter Gaussian distribution. (WCP2_2D_Gaussian_analytic) (2), Bivariate WCP1_1 prior σ\\sigma ξ\\xi generalized Pareto distribution. (WCP1_2D_GP_analytic) show example using ‘WCP1_2D_GP_analytic’ function stan. first block stan file function block includes implemented functions WCPprior package. data block specifies NN numbers independent identically distributed data generalized Pareto distribution. parameter block specifies two parameters two dimensional vector. model block can created calling stan functions ‘WCP1_2D_GP_analytic’ ‘generalized_Pareto’ WCPprior package. complete stan file following. built stored model object. Now generate simulated generalized Pareto data. First import necessary library. set σ=0.1,ξ=2/3\\sigma = 0.1, \\xi = 2/3 simulated data call function ‘rgpd’ generate data. now fit model stan. Let us plot fitted model:","code":"functions { #include /include/WCP_analytic.stan } data {   int<lower=0> N; //number of data   vector[N] y; //iid data } parameters {   real<lower = 0> sigma;   real<lower = 0, upper = 1> xi; } model {   target += WCP1_2D_GP_analytic_log(sigma, xi, 10);   y ~ generalized_Pareto(sigma, xi); } functions { #include ../inst/stan/include/WCP_analytic.stan } data {   int<lower=0> N; //number of data   vector[N] y; //iid data }  parameters {   real<lower = 0> sigma;   real<lower = 0, upper = 1> xi; } model {   target += WCP1_2D_GP_analytic_log(sigma, xi, 10);   y ~ generalized_Pareto(sigma, xi); } library(\"evmix\") true_sigma = 0.1 true_xi = 2/3 sim_data = rgpd(n = 100, u = 0, sigmau = true_sigma, xi = true_xi, phiu = 1) library(rstan) fit_WCP_2D_GP <- sampling(model, data = list(N = 100, y = sim_data), iter = 1000) ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 1). ## Chain 1:  ## Chain 1: Gradient evaluation took 3.9e-05 seconds ## Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.39 seconds. ## Chain 1: Adjust your expectations accordingly! ## Chain 1:  ## Chain 1:  ## Chain 1: Iteration:   1 / 1000 [  0%]  (Warmup) ## Chain 1: Iteration: 100 / 1000 [ 10%]  (Warmup) ## Chain 1: Iteration: 200 / 1000 [ 20%]  (Warmup) ## Chain 1: Iteration: 300 / 1000 [ 30%]  (Warmup) ## Chain 1: Iteration: 400 / 1000 [ 40%]  (Warmup) ## Chain 1: Iteration: 500 / 1000 [ 50%]  (Warmup) ## Chain 1: Iteration: 501 / 1000 [ 50%]  (Sampling) ## Chain 1: Iteration: 600 / 1000 [ 60%]  (Sampling) ## Chain 1: Iteration: 700 / 1000 [ 70%]  (Sampling) ## Chain 1: Iteration: 800 / 1000 [ 80%]  (Sampling) ## Chain 1: Iteration: 900 / 1000 [ 90%]  (Sampling) ## Chain 1: Iteration: 1000 / 1000 [100%]  (Sampling) ## Chain 1:  ## Chain 1:  Elapsed Time: 0.076 seconds (Warm-up) ## Chain 1:                0.063 seconds (Sampling) ## Chain 1:                0.139 seconds (Total) ## Chain 1:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 2). ## Chain 2:  ## Chain 2: Gradient evaluation took 2.6e-05 seconds ## Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.26 seconds. ## Chain 2: Adjust your expectations accordingly! ## Chain 2:  ## Chain 2:  ## Chain 2: Iteration:   1 / 1000 [  0%]  (Warmup) ## Chain 2: Iteration: 100 / 1000 [ 10%]  (Warmup) ## Chain 2: Iteration: 200 / 1000 [ 20%]  (Warmup) ## Chain 2: Iteration: 300 / 1000 [ 30%]  (Warmup) ## Chain 2: Iteration: 400 / 1000 [ 40%]  (Warmup) ## Chain 2: Iteration: 500 / 1000 [ 50%]  (Warmup) ## Chain 2: Iteration: 501 / 1000 [ 50%]  (Sampling) ## Chain 2: Iteration: 600 / 1000 [ 60%]  (Sampling) ## Chain 2: Iteration: 700 / 1000 [ 70%]  (Sampling) ## Chain 2: Iteration: 800 / 1000 [ 80%]  (Sampling) ## Chain 2: Iteration: 900 / 1000 [ 90%]  (Sampling) ## Chain 2: Iteration: 1000 / 1000 [100%]  (Sampling) ## Chain 2:  ## Chain 2:  Elapsed Time: 0.079 seconds (Warm-up) ## Chain 2:                0.069 seconds (Sampling) ## Chain 2:                0.148 seconds (Total) ## Chain 2:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 3). ## Chain 3:  ## Chain 3: Gradient evaluation took 2.8e-05 seconds ## Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.28 seconds. ## Chain 3: Adjust your expectations accordingly! ## Chain 3:  ## Chain 3:  ## Chain 3: Iteration:   1 / 1000 [  0%]  (Warmup) ## Chain 3: Iteration: 100 / 1000 [ 10%]  (Warmup) ## Chain 3: Iteration: 200 / 1000 [ 20%]  (Warmup) ## Chain 3: Iteration: 300 / 1000 [ 30%]  (Warmup) ## Chain 3: Iteration: 400 / 1000 [ 40%]  (Warmup) ## Chain 3: Iteration: 500 / 1000 [ 50%]  (Warmup) ## Chain 3: Iteration: 501 / 1000 [ 50%]  (Sampling) ## Chain 3: Iteration: 600 / 1000 [ 60%]  (Sampling) ## Chain 3: Iteration: 700 / 1000 [ 70%]  (Sampling) ## Chain 3: Iteration: 800 / 1000 [ 80%]  (Sampling) ## Chain 3: Iteration: 900 / 1000 [ 90%]  (Sampling) ## Chain 3: Iteration: 1000 / 1000 [100%]  (Sampling) ## Chain 3:  ## Chain 3:  Elapsed Time: 0.079 seconds (Warm-up) ## Chain 3:                0.065 seconds (Sampling) ## Chain 3:                0.144 seconds (Total) ## Chain 3:  ##  ## SAMPLING FOR MODEL 'anon_model' NOW (CHAIN 4). ## Chain 4:  ## Chain 4: Gradient evaluation took 2.8e-05 seconds ## Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.28 seconds. ## Chain 4: Adjust your expectations accordingly! ## Chain 4:  ## Chain 4:  ## Chain 4: Iteration:   1 / 1000 [  0%]  (Warmup) ## Chain 4: Iteration: 100 / 1000 [ 10%]  (Warmup) ## Chain 4: Iteration: 200 / 1000 [ 20%]  (Warmup) ## Chain 4: Iteration: 300 / 1000 [ 30%]  (Warmup) ## Chain 4: Iteration: 400 / 1000 [ 40%]  (Warmup) ## Chain 4: Iteration: 500 / 1000 [ 50%]  (Warmup) ## Chain 4: Iteration: 501 / 1000 [ 50%]  (Sampling) ## Chain 4: Iteration: 600 / 1000 [ 60%]  (Sampling) ## Chain 4: Iteration: 700 / 1000 [ 70%]  (Sampling) ## Chain 4: Iteration: 800 / 1000 [ 80%]  (Sampling) ## Chain 4: Iteration: 900 / 1000 [ 90%]  (Sampling) ## Chain 4: Iteration: 1000 / 1000 [100%]  (Sampling) ## Chain 4:  ## Chain 4:  Elapsed Time: 0.084 seconds (Warm-up) ## Chain 4:                0.063 seconds (Sampling) ## Chain 4:                0.147 seconds (Total) ## Chain 4: plot(fit_WCP_2D_GP) ## ci_level: 0.8 (80% intervals) ## outer_level: 0.95 (95% intervals)"},{"path":"https://vpnsctl.github.io/WCPprior/articles/numerical_WCP.html","id":"bivariate-wcp_2-prior-of-mean-and-standard-deviation-of-gaussian-distribution-","dir":"Articles","previous_headings":"","what":"Bivariate WCP2_2 prior of mean and standard deviation of Gaussian distribution.","title":"Numerical approximations of WCP priors","text":"theoretical details deriving bivariate WCP prior density can found Recipe 1, Section 4.2 https://arxiv.org/pdf/2312.04481.pdf, implementation details can found Recipe 4, Section 5.2 document. function gives numerical approximation bivariate WCP prior requires information. function takes values two-dimensional parameter 𝛉=(θ1,θ2)\\boldsymbol{\\theta} = (\\theta_1, \\theta_2) returns Wasserstein distance W(𝛉)W(\\boldsymbol{\\theta}). η\\eta, user-specified hyperparameter WCP prior. cutoff parameter determines upper bound Wasserstein distance WW case parameter space 𝛉\\boldsymbol{\\theta} unbounded. , solving P(W>w)=cutoffP(W > w) = \\text{cutoff}, upper bound w=−log(cutoff)/ηw = -log(\\text{cutoff})/\\eta. Thus, can approximate WCP prior bounded domain. region information specifies boundary bounded domain 𝛉\\boldsymbol{\\theta} determined cutoff, type shape domain. mesh width determine fine mesh bounded domain. Let us define Wasserstein distance function, x[1] mean parameter, x[2] standard deviation parameter: now define parameters region: Observe type region conic, range angle conic region 0 π\\pi base model parameter (0,0). following code performs approximation using WCP_2D_Numerical_Density() function. setting parallel = TRUE, user can run function multiple cores NumCores specifies number cores. set visual_mesh = TRUE obtain plot region along constructed mesh.  function returns values approximated density along level curves. goal now plot approximated density. end, obtain approximated values mesh, plot values pixelated cover mesh. begin extracting mesh creating pixelized mesh fm_pixels() function fmesher package. now obtain values approximated density mesh nodes. end, need elements basis val returned list. basis contains matrix maps level curve locations mesh nodes, val contains values approximated density level curve locations. Let us obtain values approximated density pixelated mesh: Let us now plot approximated density log scale:  Now show absolute error true approximated densities. begin obtaining values true density pixelated locations: can now add absolute errors pxl list: Now, error plot log scale:  compute total variation distance true approximated distribution, can following. start obtainig lumped mass matrix, matrix contains areas triangles mesh: Let us now obtain value true density mesh locations: can now compute approximation total variation norm: WCPprior package also provides function compute point-wise analytic bivariate WCP2_2 prior mean standard deviation Gaussian distribution. use function, users just need provide values parameters, η\\eta base model mean parameter base_mean\\text{base_mean}. base model standard deviation parameter fixed 0. Now use function compute densities coordinates numerical approximation densities computed. Let us start obtaining analytic density help WCP2_2D_Gaussian_analytic() function Let us now compare density true density computed manually: now plot analytic density:","code":"W_func <- function(x){sqrt(x[1]^2+x[2]^2)} cutoff = 0.01 mesh_width = 0.3 # user-specified hyperparameter eta = 1  region = list(type = 'conic', lower_angle = 0,  upper_angle = pi, base_theta = c(0,0)) result = WCP_2D_Numerical_Density(W_func,                           eta = eta,                           mesh_width = mesh_width,                            cutoff = cutoff,                            region = region,                           parallel = TRUE,                           NumCores = 2,                           visual_mesh = TRUE) library(fmesher) mesh <- result$mesh pxl <- fm_pixels(mesh) basis <- result$basis dens_val <- result$val  dens_mesh <- basis(dens_val) pxl$val <-      fm_evaluate(mesh, pxl, field =        dens_mesh) library(viridis)   ggplot() +     geom_tile(       data = pxl,       aes(geometry = geometry, fill = log(val)),       stat = \"sf_coordinates\"     ) + scale_fill_viridis() library(sf) coord_pxl <- st_coordinates(pxl) # compute the true density true_WCP_density = ( 1/sqrt(coord_pxl[,1]^2 +                  coord_pxl[,2]^2) ) * eta *                  exp(-eta * sqrt(coord_pxl[,1]^2 +                  coord_pxl[,2]^2))/pi pxl$error <- abs(pxl$val - true_WCP_density) ggplot() +     geom_tile(       data = pxl,       aes(geometry = geometry, fill = log(error)),       stat = \"sf_coordinates\"     ) + scale_fill_viridis() mass_lump_C <- result$C true_WCP_density_mesh = ( 1/sqrt(mesh$loc[,1]^2 +                  mesh$loc[,2]^2) ) * eta *                  exp(-eta * sqrt(mesh$loc[,1]^2 +                  mesh$loc[,2]^2))/pi TVD_error = 0.5 * (sum(mass_lump_C %*%        abs(matrix(dens_mesh,ncol = 1) -          matrix(true_WCP_density_mesh,ncol = 1))) +          cutoff) print(TVD_error) ## [1] 0.01822381 analytic_density = numeric()  for (i in 1:length(coord_pxl[,1])){   analytic_density[i] =              WCP2_2D_Gaussian_analytic(mean =                        coord_pxl[i,1],                        std = coord_pxl[i,2],                       eta = 1,                       base_mean = 0) } print(sum(abs(true_WCP_density - analytic_density))) ## [1] 0 data = cbind(as.vector(coord_pxl[,1]),           as.vector(coord_pxl[,2]),           as.vector(analytic_density)) data = data.frame(data) g = ggplot(data, aes(X1, X2, fill = log(X3)))+   geom_raster()+   scale_fill_viridis() +   labs(x = expression(theta[1]), y = expression(theta[2])) +    guides(col = guide_colourbar(title = \"Density\"))+   theme(legend.position = \"top\",         legend.key.height = unit(0.1, 'cm'), #change legend key height         legend.key.width = unit(0.5, 'cm'), #change legend key width         legend.title = element_text(size=7), #change legend title font size         legend.text = element_text(size=5),#change legend text font size         axis.text=element_text(size=7),         axis.title=element_text(size=7))  g"},{"path":"https://vpnsctl.github.io/WCPprior/articles/numerical_WCP.html","id":"wcp_2-prior-of-reciprocal-of-degree-of-freedom-of-t-distribution-","dir":"Articles","previous_headings":"","what":"WCP2_2 prior of reciprocal of degree of freedom of t-distribution.","title":"Numerical approximations of WCP priors","text":"theoretical implementation details WCP2_2 prior reciprocal degree freedom parameter t-distribution can found Section 5.1 https://arxiv.org/pdf/2312.04481.pdf. Let ξ\\xi denote parameter interest. use function construct numerical approximation WCP prior single parameter, users need provide following information general: (1), function takes values two-dimensional parameter θ\\theta returns Wasserstein distance W(θ)W(\\theta). (2), θ0\\theta_0, base model parameter. (3), η\\eta, user-specified hyperparameter WCP prior. (4), cutoff parameter. (5), Lower upper bound domain θ\\theta two values included . Since ξ∈[0,1/2)\\xi\\[0,1/2) bounded domain, need provide cutoff parameter case. Also, analytic expression W(ξ)W(\\xi) available case, compute numerically numerical integration (see Remark 1 https://arxiv.org/pdf/2312.04481.pdf). However, call function frequently economic, construct interpolated function W(ξ)W(\\xi) following code. determine η\\eta requiring P(W(ξ)>U)=αP(\\text{W}(\\xi) > U) = \\alpha. Now ready call function compute numerically approximated WCP prior. base_theta\\text{base_theta} base model parameter. L\\text{L} U\\text{U} denote lower upper bound θ\\theta. L_included\\text{L_included} U_included\\text{U_included} indicate L\\text{L} U\\text{U} included interval parameter interest. mesh_width\\text{mesh_width} denote mesh width domain. User may instead input mesh_n\\text{mesh_n} specifies number mesh nodes determine mesh. output contains vector values ξ\\xi vector approximated densities evaluated ξ\\xi. visualization result :","code":"library(fGarch) # The Wasserstein distance function by numerical integration W2distanceGt = function(xi){   # xi is 1/nu where nu is dof of t-distribution   integrand = function(p,...){     abs(qstd(p,...) - qnorm(p))^2   }   integral = integrate(Vectorize(integrand),0,1,        nu = 1/xi,subdivisions = 10000L)$value   return (integral^(1/2)) } # a sequence of xi Xi = seq(from = 0.01,to = 0.49,by = 0.01) # obtain a sequence of W(xi) by W2distanceGt function W2distance = c() xi = c() for (i in 1:length(Xi)){   # skip the case of problematic numerical integration   temp = try(W2distanceGt(Xi[i]), silent = FALSE)   if ('try-error' %in% class(temp)){     next   }   W2distance = c(W2distance, W2distanceGt(Xi[i]) )   xi = c(xi, Xi[i]) } # the interpolated function of W(xi) W2d = splinefun(xi, W2distance, method = \"hyman\") alpha = 0.3 U = 0.1 eta = -log(alpha)/W2d(U) result = WCP_1D_Numerical_Density(base_theta = 0,                                    L = 0,                                     L_included = TRUE,                                    U = 0.5,                                    U_included = FALSE,                                    W_func = W2d,                                    eta = eta,                                    mesh_width = 0.001) data <- data.frame(x = result[,1], density = result[, 2]) ggplot(data, aes(x = x, y = density)) + geom_line()"},{"path":"https://vpnsctl.github.io/WCPprior/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Author. Alexandre Simas. Maintainer, author. Zhen Xiong. Author.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bolin D, Simas , Xiong Z (2023). WCPprior: Wasserstein Complexity Penalization Priors. R package version 1.0, https://vpnsctl.github.io/WCPprior/. Bolin D, Simas , Xiong Z (2023). “Wasserstein complexity penalization priors: new class penalizing complexity priors.” arXiv preprint arXiv:2312.04481. doi:10.48550/arXiv.2312.04481.","code":"@Manual{,   title = {WCPprior: Wasserstein Complexity Penalization Priors},   author = {David Bolin and Alexandre B. Simas and Zhen Xiong},   year = {2023},   note = {R package version 1.0},   url = {https://vpnsctl.github.io/WCPprior/}, } @Article{,   title = {Wasserstein complexity penalization priors: a new class of penalizing complexity priors},   author = {David Bolin and Alexandre B. Simas and Zhen Xiong},   year = {2023},   journal = {arXiv preprint arXiv:2312.04481},   doi = {10.48550/arXiv.2312.04481}, }"},{"path":[]},{"path":"https://vpnsctl.github.io/WCPprior/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Wasserstein Complexity Penalization Priors","text":"WCPprior R package used obtain numerical approximation Wasserstein complexity penalization (WCP) priors. package also contains several analytical WCP priors well implementations STAN INLA.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Wasserstein Complexity Penalization Priors","text":"latest development version can installed using command latest stable version can installed using command","code":"remotes::install_github(\"vpnsctl/WCPprior\", ref = \"devel\") remotes::install_github(\"vpnsctl/WCPprior\", ref = \"stable\")"},{"path":"https://vpnsctl.github.io/WCPprior/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Wasserstein Complexity Penalization Priors","text":"D. Bolin, . Simas, Z. Xiong (2023+) Wasserstein complexity penalization priors: new class penalizing complexity priors. arXiv preprint.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_1D_GPtail_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","title":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","text":"1d analytic density WCP prior xi generalized Pareto distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_1D_GPtail_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","text":"","code":"WCP1_1D_GPtail_analytic(seq_xi, eta, inla_table = FALSE)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_1D_GPtail_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","text":"seq_xi vector values xi parameter. eta User specified parameter WCP prior. inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_1D_GPtail_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d analytic density WCP prior for xi of generalized Pareto distribution — WCP1_1D_GPtail_analytic","text":"list including densities seq_xi inla table","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_2D_GP_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","title":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","text":"2d analytic density WCP prior sigma xi generalized Pareto distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_2D_GP_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","text":"","code":"WCP1_2D_GP_analytic(sigma, xi, eta)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_2D_GP_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","text":"sigma Sigma parameter. xi Xi parameter. eta User specified parameter WCP prior.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP1_2D_GP_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d analytic density WCP prior for sigma and xi of generalized Pareto distribution — WCP1_2D_GP_analytic","text":"value density evaluated c(sigma, xi).","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_AR1_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","title":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","text":"1d analytic density WCP prior phi stationary AR1 process","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_AR1_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","text":"","code":"WCP2_1D_AR1_analytic(seq_phi, eta, n, sigma, inla_table = FALSE)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_AR1_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","text":"seq_phi vector values phi parameter. eta User specified parameter WCP prior. n Length AR1 process. sigma Standard deviation process. inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_AR1_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d analytic density WCP prior for phi of stationary AR1 process — WCP2_1D_AR1_analytic","text":"list including densities seq_phi inla table","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_mean_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","title":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","text":"1d analytic density WCP2 prior mean Gaussian distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_mean_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","text":"","code":"WCP2_1D_Gaussian_mean_analytic(seq_m, eta, inla_table = FALSE)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_mean_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","text":"seq_m vector values mean parameter. eta User specified parameter WCP prior. inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_mean_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d analytic density WCP2 prior for mean of Gaussian distribution — WCP2_1D_Gaussian_mean_analytic","text":"list including densities seq_m inla table","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_precision_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","title":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","text":"1d analytic density WCP2 prior tau (1/variance) Gaussian distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_precision_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","text":"","code":"WCP2_1D_Gaussian_precision_analytic(seq_tau, eta, inla_table = FALSE)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_precision_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","text":"seq_tau vector values tau parameter. eta User specified parameter WCP prior. inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_1D_Gaussian_precision_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d analytic density WCP2 prior for tau (1/variance) of Gaussian distribution — WCP2_1D_Gaussian_precision_analytic","text":"list including densities seq_tau inla table","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_2D_Gaussian_analytic.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","title":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","text":"2d analytic density WCP prior mean standard deviation Gaussian distribution","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_2D_Gaussian_analytic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","text":"","code":"WCP2_2D_Gaussian_analytic(mean, std, eta, base_mean)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_2D_Gaussian_analytic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","text":"mean Mean parameter. std Standard deviation parameter. eta User specified parameter WCP prior. base_mean Base model value mean parameter.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP2_2D_Gaussian_analytic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d analytic density WCP prior for mean and standard deviation of Gaussian distribution — WCP2_2D_Gaussian_analytic","text":"value density evaluated c(mean, std).","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_1D_Numerical_Density.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","title":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","text":"1d numerical density WCP prior","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_1D_Numerical_Density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","text":"","code":"WCP_1D_Numerical_Density(   W_func,   eta,   base_theta,   L,   U,   mesh_width = NULL,   mesh_n = 100,   cutoff1 = 0.01,   cutoff2 = NULL,   L_included = FALSE,   U_included = FALSE,   inla_table = FALSE )"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_1D_Numerical_Density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","text":"W_func function returns Wasserstein distance given theta. eta User specified parameter WCP prior. base_theta Base model theta. L Lower bound theta. U Upper bound theta. mesh_width Mesh width used. used, mesh_n used. mesh_n Number mesh nodes used. used mesh_width given. cutoff1 Cutoff parameter decide upper bound Wasserstein distance right hand side base_theta. cutoff2 Cutoff parameter decide upper bound Wasserstein distance left hand side base_theta. L_included L included domain, TRUE FALSE value U_included U included domain, TRUE FALSE value inla_table results returned table used INLA? Default FALSE.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_1D_Numerical_Density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d numerical density WCP prior — WCP_1D_Numerical_Density","text":"list density locations densities evaluated locations.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_2D_Numerical_Density.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","title":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","text":"2d numerical approximation WCP prior","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_2D_Numerical_Density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","text":"","code":"WCP_2D_Numerical_Density(   W_func,   eta,   mesh_width,   alpha = 1,   tau = mesh_width/1000,   cutoff = 0.01,   region = list(type = \"conic\", lower_angle = 0, upper_angle = pi, base_theta = c(0, 0)),   lc_multiplier = 20,   buff_boundary = FALSE,   parallel = FALSE,   NumCores = parallel::detectCores() - 1,   visual_mesh = FALSE )"},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_2D_Numerical_Density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","text":"W_func function returns Wasserstein distance given theta1 theta2. eta User specified parameter WCP prior. mesh_width Mesh width. alpha Power mesh width finer mesh. tau tau parameter, indicating much bounded away boundary. cutoff Cutoff parameter indicating probability tail mass Wasserstein distance. region list specify region information. example, strip regions (regions type IxJ, = (,b) J = (c,d) intervals, one unbounded), one can set `region = list(type = \"strip\", base_theta = c(,c), corners = c(,b,c,d))`, values ``,`b`,`c` `d` can `-Inf` `Inf`. type conic, list must set, example, list(type = 'conic', lower_angle = 0, upper_angle = pi, base_theta = c(0,0)), `lower_angle` `upper_angle` contains smaller larger angles determine cone. lc_multiplier Multiplier determines number level curves buff_boundary additional buffer (magnitude mesh_width) added region bound away boundary domain? parallel logic value indicating whether user wants run function multiple cpu. NumCores Number cores run function. visual_mesh logic value determin whether plot mesh.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCP_2D_Numerical_Density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d numerical approximation of WCP prior — WCP_2D_Numerical_Density","text":"list density locations, densities evaluated locations utilities can help access accuracy.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/WCPprior.html","id":null,"dir":"Reference","previous_headings":"","what":"Wasserstein Complexity Penalization Priors — WCPprior","title":"Wasserstein Complexity Penalization Priors — WCPprior","text":"'WCPprior' provides tools computing Wasserstein complexity penalization priors.","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/compute_partial_arc_lengths.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute partial arc lengths — compute_partial_arc_lengths","title":"Compute partial arc lengths — compute_partial_arc_lengths","text":"Computes partial arc lengths matrix coordinates SpatialLine","code":""},{"path":"https://vpnsctl.github.io/WCPprior/reference/compute_partial_arc_lengths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute partial arc lengths — compute_partial_arc_lengths","text":"","code":"compute_partial_arc_lengths(coords)"},{"path":"https://vpnsctl.github.io/WCPprior/reference/compute_partial_arc_lengths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute partial arc lengths — compute_partial_arc_lengths","text":"coords [nx2 matrix] Matrix points lines","code":""}]
